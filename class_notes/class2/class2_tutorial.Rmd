---
title: "Geoprocessing and Vector Data Analysis"
author: "Aditya Ranganath"
date: "3/31/2022"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=F, warning=F}
library(WDI)
library(sf)
library(tmap)
library(rnaturalearth)
library(rnaturalearthdata)
library(tidyverse)
library(grid)
library(tidycensus)
library(tidygeocoder)
library(units)
```

```{r, echo=F, warning=F}
library(DT) 
```

# Scripting tools: functions and iteration with the tidyverse

```{r}
country_boundaries<-ne_countries(scale="medium", returnclass="sf") %>% 
                       filter(iso_a3 !="ATA")
                    
```

```{r}
tm_shape(country_boundaries)+
  tm_polygons()
```

```{r}
trade_gdp_2010_2018<-WDI(country="all", # specifies we want data for all countries available
                                indicator="NE.TRD.GNFS.ZS", # specifies code for desired indicator
                                start=2010, # Start year for data series
                                end=2018, # End year for data series
                                extra=T) # returns
```


```{r}
trade_gdp_2015<-
  trade_gdp_2010_2018 %>%  # Establishes object to be modified
  filter(year=="2015") %>% # Subsets observations where the "year" variable equals "2015"
  rename(trade_gdp_2015=NE.TRD.GNFS.ZS)
```

```{r}
trade_2015_spatial<-full_join(country_boundaries, trade_gdp_2015,
                                    by=c("iso_a3"="iso3c"))
```

```{r}
tm_shape(trade_2015_spatial)+
  tm_polygons(col="trade_gdp_2015",
              n=7,
              style="quantile",
              palette="YlOrBr",
              title="Trade as a % of GDP,\n2015",
              textNA="No Data")+
    tm_layout(legend.outside=T,
              legend.outside.position = "bottom",
              main.title="Crossnational Variation in Commercial Integration, 2015",
              main.title.size=1,
              main.title.position="center",
              inner.margins=c(0.06,0.10,0.10,0.08), # Sets margins to create whitespace
              frame=FALSE,
              attr.outside = TRUE)+ # Places credits section outside map
   tm_credits("Map Author: Aditya Ranganath\nData Source: World Bank\nDevelopment Indicators (WDI)", position=c(0.78,0), size=0.38) # Specifies content, position, size of credits
```

```{r}
wdi_map_maker<-function(wdi_variable_code, start_year, end_year, 
                        legend.title, main_map_title){

country_boundaries<-ne_countries(scale="medium", returnclass="sf") %>% 
                       filter(iso_a3 !="ATA")
  
wdi_extract<-WDI(country="all",
              indicator=wdi_variable_code,
              start=start_year,
              end=end_year,
              extra=T)

spatial_object_tomap<-full_join(country_boundaries, wdi_extract,
                                    by=c("iso_a3"="iso3c"))

final_map<-tm_shape(spatial_object_tomap)+
  tm_polygons(col=wdi_variable_code,
              n=7,
              style="quantile",
              palette="YlOrBr",
              title=legend.title,
              textNA="No Data")+
    tm_layout(legend.outside=T,
              legend.outside.position = "bottom",
              main.title=main_map_title,
              main.title.size=1,
              main.title.position="center",
              inner.margins=c(0.06,0.10,0.10,0.08), # Sets margins to create whitespace
              frame=FALSE,
              attr.outside = TRUE)+ # Places credits section outside map
   tm_credits("Map Author: Aditya Ranganath\nData Source: World Bank\nDevelopment Indicators (WDI)", position=c(0.78,0), size=0.38) # Specifies content, position, size of credits
return(final_map)
}
```


```{r}
wdi_map_maker(wdi_variable_code="BG.GSR.NFSV.GD.ZS", start_year=2017, end_year=2017, 
                        legend.title="Services Trade (% of GDP)", main_map_title="Service Market Integration, 2017")
```


```{r}
wdi_map_maker(wdi_variable_code="GC.TAX.TOTL.GD.ZS", start_year=2017, end_year=2017, 
                        legend.title="Taxes (% of GDP)", main_map_title="Government Taxes as a Share of GDP, 2017")
```


```{r}
input_list<-list(wdi_variable_code=c("BG.GSR.NFSV.GD.ZS", "GC.TAX.TOTL.GD.ZS"),
                 start_year=c(2017, 2017),
                 end_year=c(2017, 2017),
                 legend.title=c("Services Trade (% of GDP)", "Taxes (%GDP)"),
                 main_map_title=c("Service Market Integration, 2017", "Government Taxes as a Share of GDP, 2017")) 
```


```{r}
map_list<-pmap(input_list, wdi_map_maker)
```


```{r}
map_list[[1]]
```

```{r}
map_list[[2]]
```

# Layering Data 

One of the most powerful features of GIS software is the ability to layer different spatial datasets on top of each other, which can help us to visualize spatial relationships. To see how this works, let's layer two vector layers together. The first layer is a polygon dataset of the world's country boundaries, which you will recall from last class. Let's extract this dataset and visualize it below:

```{r, fig.asp=0.5}
# Extracts spatial dataset of country polygons from "rnaturalearth" package and assigns it to an object named "country_boundaries"
country_boundaries<-ne_countries(scale="medium", returnclass="sf") %>% 
                       filter(iso_a3 !="ATA")

# Renders spatial information in "country_boundaries" using tmap
tm_shape(country_boundaries)+
  tm_polygons()
```

Now, let's take another vector dataset, and layer it over these polygons. In particular, we'll work with a global dataset of World Bank foreign aid projects, available through the AidData Project, available at 
[https://www.aiddata.org/data/world-bank-geocoded-research-release-level-1-v1-4-2](https://www.aiddata.org/data/world-bank-geocoded-research-release-level-1-v1-4-2). 

To save time, I preprocessed the data beforehand, and you can find the version that we'll work with on this [page](https://www.dropbox.com/sh/6yue5opad2uhqvs/AABu7S4R_w6B_dnbt7Yqi_qQa?dl=0) (to create this dataset, I merged the "locations.csv" file into the "projects.csv" file using "project_id" as the join variable; all of these data are available on the dataset's AidData page cited above). 

You can download the processed version of the dataset into your working directory, and then read it into R Studio using ```read_csv("worldbank_project_locations.csv")```. Alternatively, you can read it straight into R Studio from the Dropbox location; to do so, simply copy the link to the CSV, change the "0" at the end of the url to a "1", and pass it to the ```read_csv()` function, as below; here, we'll assign this dataset to an object named ```worldbank_project_locations```: 

```{r, message=F}
worldbank_project_locations<-read_csv("https://www.dropbox.com/sh/6yue5opad2uhqvs/AABgduyoPtki2C47rWMDfezta/worldbank_projects_locations.csv?dl=1")
```

Go ahead and open up the dataset by passing the name of the object tin the data viewer, and have a look:

```{r}
# Opens "worldbank_project_locations" in data viewer
View(worldbank_project_locations)
```

```{r, echo=F, warning=F}
worldbank_project_locations<-worldbank_project_locations %>% relocate(recipients, project_id, latitude, longitude)

worldbank_project_locations %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 2)
))
```

You'll see that there is a "latitude" field and a "longitude" field, which together define each World Bank project's location on the Earth's surface, based on the WGS1984 coordinate system (i.e. the coordinate system used by GPS devices). However, the dataset itself is not yet a spatial object; it's actually a regular data frame, which we can confirm with the following:   

```{r}
# Finds class of "worldbank_project_locations"
class(worldbank_project_locations)
```

In order to turn this regular, tabular dataset into a spatial data object that we can work with in a GIS framework, we must pass ```worldbank_project_locations``` to the ```st_as_sf()``` function; within the function, we must also specify the names of the fields containing the longitude and latitude coordinates (```coords=c("longitude", "latitude")```), and the underlying coordinate reference system used to measure these lat/long values. In this case, that coordinate reference system is WGS84, and we can specify this using its EPSG code, which is 4326, by setting ```crs=4326```. The ```st_as_sf()``` function will use this information (i.e. the names of the fields containing the longitude and latitude coordinates, and the coordinate reference system), and transform ```worldbank_project_locations``` into a spatial dataset of point locations; we'll assign this spatial dataset to a new object named ```worldbank_locations_spatial```: 

```{r}
worldbank_locations_spatial<-st_as_sf(worldbank_project_locations, coords=c("longitude", "latitude"), crs=4326)
```

We can confirm that ```worldbank_locations_spatial``` is indeed a spatial object with the following:

```{r}
class(worldbank_locations_spatial)
```

Now that we've created a new vector dataset comprised of points (representing WB project locations), let's go ahead and visualize these locations using *tmap*. The code below should be familiar, but note that instead of using the ```tm_polygons()``` function to render the dataset's spatial information, we use ```tm_dots()```, which is the *tmap* function that can be used to render point data. Note that if we had a vector dataset comprised of line (rather than polygon or point) data, we could render those lines with ```tm_lines()```. 

```{r, fig.asp=0.5}
tm_shape(worldbank_locations_spatial)+
  tm_dots()
```

We can now see the distribution of projects, scattered across the developing world. Above, we plotted the WB project location spatial dataset by itself. Now, let's view our point dataset in relation to our polygon dataset of world country boundaries (```country_boundaries```). 

Before plotting the two datasets together, however, it's important to always make sure that they're in the same coordinate reference system; if they are in different coordinate reference system, the resulting visual display (and any subsequent calculations we perform using these datasets) will be inaccurate, since they use different frames of reference. Here, we are in good shape, since we already explicitly defined the CRS for ```worldbank_locations_spatial```. And, with respect to  ```country_boundaries```, note the metadata when we print the object:

```{r, eval=F}
country_boundaries
```

```{r, echo=F}
head(country_boundaries, n=1)
```

The string that reads "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0" is equivalent to "EPSG: 4326", so these two datasets are aligned. If you're ever in doubt about whether two datasets have the same CRS, a quick way to set one dataset's CRS equal to another's is via the ```st_transform()``` function. Let's say, for the sake of argument, that ```country_boundaries``` was in another CRS; in order to set it equal to the CRS of ```worldbank_locations_spatial``` we could have done the following:

```{r, eval=F}
country_boundaries<-st_transform(country_boundaries, crs=4326)
```

4326, of course, is the EPSG code that corresponds to the CRS used in ```worldbank_locations_spatial```. Another way to set the coordinate systems equal to each other would be the following:

```{r}
country_boundaries<-st_transform(country_boundaries, crs=st_crs(worldbank_locations_spatial))
```

Above, instead of explicitly setting the CRS, we use the ```st_crs()``` function to extract the CRS of ```worldbank_locations_spatial```, and then attach this CRS to ```country_boundaries``` via the ```st_transform``` function. 

Having confirmed that both of our vector datasets are in the same CRS, we can go ahead and plot them together using *tmap*. The syntax required to plot different datasets in relation to each other is simple; we can essentially connect the syntax we already used to create our individual plots together using a "+" sign. That is, we can plot our polygons (representing countries) with the following:

```{r, fig.asp=0.5}
tm_shape(country_boundaries)+
  tm_polygons()
```

And we can plot our points (representing WB foreign aid project locations) with the following:

```{r, fig.asp=0.5}
tm_shape(worldbank_locations_spatial)+
  tm_dots()
```

And, to plot them in relation to each other, we can simply use the following: 

```{r, fig.asp=0.5}
tm_shape(country_boundaries)+
  tm_polygons()+
tm_shape(worldbank_locations_spatial)+
  tm_dots()
```

Note that order matters. We can think of each spatial representation as its own layer, with layers added on top of each other. So, in the code above, the ```country_boundaries``` layer is the first layer, and the ```worldbank_locations_spatial``` is the second layer added on top of the first. If we were to reverse the order, our country polygons would obscure most of our points (assuming that the polygons are not made transparent): 

```{r, fig.asp=0.5}
tm_shape(worldbank_locations_spatial)+
  tm_dots()+
tm_shape(country_boundaries)+
  tm_polygons()
```

As we noted in our last class, we can always assign the code used to visually render spatial datasets using *tmap* to objects. For example:

```{r}
country_polygons<-tm_shape(country_boundaries)+
                    tm_polygons()

WB_aid_locations<-tm_shape(worldbank_locations_spatial)+
                    tm_dots()
```

Now, we can recreate our earlier plot with the following:

```{r, fig.asp=0.5}
country_polygons+
WB_aid_locations
```

Of course, ```country_polygons+WB_aid_location``` itself could be assigned to its own object, which will store the map for future use. For example:

```{r}
aid_map<-country_polygons+
            WB_aid_locations
```

Now, we can bring up our layers whenever we want by printing the object name:

```{r, fig.asp=0.5}
aid_map
```

We can customize our layers in any number of ways using the sorts of *tmap* functions and arguments that we learned about last week. To take a simple example, let's change the color scheme of our layers:

```{r, echo=-1, fig.asp=0.5}
tmap_mode("plot")
worldmap_projects<-
  tm_shape(country_boundaries)+
    tm_polygons("red2")+
  tm_shape(worldbank_locations_spatial)+
    tm_dots("lightblue1")

worldmap_projects
```

# Spatial joins

The ability to juxtapose different datasets together, and develop a visual representation of how they relate to each other, is powerful in and of itself. Often, however, we want to get a more precise quantitative sense of how different vector datasets are related. One of the most powerful (yet still relatively simple) GIS techniques used to formally bring together different vector datasets and extract information about their relationship is known as the spatial join. A spatial join is a  procedure that allows you to link datasets based on the relative spatial locations of their observations, even in the absence of a common field (of the sort that could facilitate a table join). In other words, a spatial join allows you to join datasets based on shared location attributes, even when those datasets donâ€™t have a common field that can be used to carry out a conventional table join (akin to the one we carried out in our previous class, when we joined datasets together based on their shared 3-digit ISO code). 

This section will motivate the concept of a spatial join using an applied example that uses the foreign aid data introduced above (```worldbank_locations_spatial```). In addition to this data, we'll also bring in a new dataset, a polygon vector dataset that delineates constituency boundaries in the African country of Malawi. The data is available in this GIS data [repository](https://geo.nyu.edu/catalog/stanford-hs879xj7186), hosted at NYU (although the data itself is from Stanford and openly licensed). Please go ahead and download the shapefile to your working directory by clicking the blue "Original Shapefile" button.

Once the data has been downloaded, you can read it into R Studio by passing the name of the file "MAA.shp" to the ```st_read()``` function, which is the *sf* function that allows one to import vector GIS datasets into R as sf objects. Below, we'll assign this dataset to a new object named ```Malawi_constituencies```. 

```{r, echo=-1}
setwd("class_notes/class2/data/data_malawi")
Malawi_constituencies<-st_read("MAA.shp")
```

Go ahead and view this spatial dataset's attribute table, using the ```View()``` function:

```{r}
View(Malawi_constituencies)
```

```{r, echo=F}
Malawi_constituencies %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 1)
))
```

Now, let's render the polygon geometries of the Malawi constituency boundaries dataset using *tmap*:  

```{r}
tm_shape(Malawi_constituencies)+
  tm_polygons()
```

Let's now turn back to ```worldbank_locations_spatial``` and, extract the Malawi observations from that global dataset. Moreoever, let's say we're only interested in projects with over $25,000,000 committed. The code below takes the global dataset of World Bank development aid projects (```worldbank_locations_spatial```), and uses the ```filter()``` function to extract the observations where the "recipients" field is equal to "Malawi", and the "total_commitments" field is greater than 25000000; it then assigns the dataset extracted from this subsetting operation to a new object named ```malawi_foreignaid_sites```. 

```{r}
malawi_foreignaid_sites<-worldbank_locations_spatial %>% 
                              filter(recipients=="Malawi" & total_commitments>25000000)
```

Let's now overlay ```Malawi_foreignaid_sites``` against the polygon layer of ```Malawi_constituencies```:

```{r}
tm_shape(Malawi_constituencies)+
  tm_polygons("red2")+
tm_shape(malawi_foreignaid_sites)+
  tm_dots("lightblue1")
```

Recall that you can always view these geometries in an interactive setting by setting ```tmap_mode("view")```:

```{r, eval=F}
tmap_mode("view")

tm_shape(Malawi_constituencies)+
  tm_polygons("red2")+
tm_shape(malawi_foreignaid_sites)+
  tm_dots("lightblue1")
```

```{r, echo=F}
tmap_mode("plot")
```

When plotting point data, it is often the case that many observations are in exactly the same location; because these points overlap perfectly (and hence show up as only a single point), it can be difficult to identify large point clusters. One quick way to address this issue is to "jitter", or add a small degree or arbitrary noise to our points before displaying them; this will help salient observational clusters stand out:

```{r}
tm_shape(Malawi_constituencies)+
  tm_polygons("red2")+
tm_shape(malawi_foreignaid_sites)+
  tm_dots("lightblue1", jitter=0.18)
```

Now, let's say that we want to precisely calculate the total number of foreign aid project sites within each constituency. This is the sort of information that a spatial join can help uncover; even though our datasets do not have a common field that can be used to implement a traditional table join, a spatial join can leverage information about the relative spatial locations of our objects of interest, and yield explicit information about which constituency each project site is located in. 

To implement a spatial join, it is extremely important that the two datasets share the same CRS. Because of the libraries that *sf* uses to implement this procedure, it will throw a warning if you attempt a spatial join with datasets in an unprojected coordinate system (like EPSG: 4326), but it is usually safe to ignore (provided your polygons don't cover the North Pole or South Pole) provided the coordinate systems are the same. However, just to get some practice in reprojecting data, let's project our datasets into a projected coordinate system appropriate for Malawai; taking this step would be essential if we planned to do distance or area calculations with the dataset (for example, calculating the number of projects per square km). A bit of research uncovers that the CRS associated with EPSG: 20936 would be appropriate for Malawi (see [here](https://epsg.io/20936)) so let's project both our datasets into this projection. 

First, we'll project ```Malawi_constituencies``` into EPSG:20936 and assign the reprojected spatial dataset to a new object named ```Malawi_constituencies_projected```:

```{r}
Malawi_constituencies_projected<-st_transform(Malawi_constituencies, 20936)
```

We'll do the same for ```malawi_foreignaid_sites```, and assign the reprojected version of this dataset to a new object named ```malawi_foreignaid_sites_projected```: 

```{r}
malawi_foreignaid_sites_projected<-st_transform(malawi_foreignaid_sites, 20936)
```

Now, we're ready to spatially join our datasets, which we can do using the ```st_join()``` function in *sf*. Below, we'll use ```malawi_foreignaid_sites_projected``` as our "main" dataset, and join ```Malawi_constituencies_projected``` to it based on the spatial information embedded in the datasets. We'll assign the product of the join to a new object named ```malawi_projects_constituencies_spatialjoin```: 

```{r}
malawi_projects_constituencies_spatialjoin<-st_join(malawi_foreignaid_sites_projected, Malawi_constituencies_projected )
```

Let's see what this dataset looks like:

```{r}
View(malawi_projects_constituencies_spatialjoin)
```

```{r, echo=F}
malawi_projects_constituencies_spatialjoin %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

If you scroll across the table, you'll notice that for every project, we now have information about its location with respect to Malawi constituencies (given by the "ID" variable right after the "geometry" column; in effect, these IDs identify 4th level administrative districts); this is information we did not have before, and which we could not have ascertained through a regular table join, but which we were able to acquire through the implementation of the spatial join. 

If we reverse the order of the join, using ```Malawi_constituencies_projected``` as the "main" dataset to which we join ```malawi_foreignaid_sites_projected```, the product of the join will look slightly different. Instead of a project-level dataset with constituency information attached to each project, we will instead have a constituency-level dataset with information about each project associated with a constituency (if a constituency is associated with more than one project, there will be more than one row for that constituency). To make this more concrete, let's reverse the join, and see what the product looks like. Below, we call the same ```st_join()``` function, but reverse the order of the arguments, such that ```Malawi_constituencies_projected``` is first, and ```malawi_foreignaid_sites_projected``` is second. We'll assign the product of this join to a new object named ```malawi_constituencies_projects_spatialjoin```: 

```{r}
malawi_constituencies_projects_spatialjoin<-st_join(Malawi_constituencies_projected, malawi_foreignaid_sites_projected )
```

Let's open up the dataset, and note the difference compared to ```malawi_projects_constituencies_spatialjoin```:

```{r}
View(malawi_constituencies_projects_spatialjoin)
```

```{r, echo=F}
malawi_constituencies_projects_spatialjoin %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

The direction of the spatial join is largely determined by the context of the problem, and the question that is under investigation; there is no "right" direction (here, spatially joining ```malawi_foreignaid_sites_projected``` to ```Malawi_constituencies_projected``` is just as valid as the inverse operation of spatially joining  ```Malawi_constituencies_projected``` to ```malawi_foreignaid_sites_projected```; which option makes more sense will depend on the question one is trying to answer)

Recall that our goal was to extract information about the number of World Bank project sites within each constituency; to do so, we'll work with ```malawi_projects_constituencies_spatialjoin```.

We can leverage some basic *dplyr* functions to extract the information we need; below, we'll take ```malawi_projects_constituencies_spatialjoin```, and then specify ```group_by(ID)``` to indicate that we want to calculate group-level information with respect to the "ID" variable, which uniquely identifies constituencies. Then, ```summarize(n())``` counts up the total number of records within each ID group of ```malawi_projects_constituencies_spatialjoin```; in effect, this is the total number of projects within each constituency. Let's assign this data to a new object named ```project_sites_per_constituency```:

```{r}
project_sites_per_constituency<-malawi_projects_constituencies_spatialjoin %>% 
                           group_by(ID) %>% 
                           summarize(n())
```

And, when we view this newly generated dataset, it looks something like this:

```{r}
View(project_sites_per_constituency)
```

```{r, echo=F}
project_sites_per_constituency %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

```{r}
View(project_sites_per_constituency)
```

Let's go ahead and rename the "n()" column, which contains information on the total number of project sites in each constituency (uniquely identified by the ID variable), to something more descriptive:

```{r}
project_sites_per_constituency<-project_sites_per_constituency %>% 
                                rename(sum_projects="n()")
```

Let's join this data back into our projected constituency-level spatial dataset, ```Malawi_constituencies_projected```, based on the ID variable. To do so, we first have to convert ```project_sites_per_constituency``` into a data frame object, since the *sf* package does not support joining two spatial objects together based on a common tabular field. We'll assign the data frame object to a new object named ```project_sites_per_constituency_df```. 

```{r}
project_sites_per_constituency_df<-as.data.frame(project_sites_per_constituency)
```

Now, let's implement the table join (using "ID" as the join field), and assign the product to a new object named ```malawi_constituencies_projects_spatial```: 

```{r}
malawi_constituencies_projects_spatial<-full_join(Malawi_constituencies_projected, project_sites_per_constituency_df, by="ID")
```

```{r}
View(malawi_constituencies_projects_spatial)
```

```{r, echo=F}
malawi_constituencies_projects_spatial %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

If you scroll across, you'll notice we now have a field, named "sum_projects", with information on the number of project sites in each constituency. 

You may notice that many of the observations have "NA" values, indicating that there were no projects in these constituencies. It may be useful to replace these "NAs" with "0", since that would be a more accurate representation in this case. To do so, we can use the `replace_na``` function. Below, we'll also relocate the "total_unique_projects" to the front of the dataset

```{r}
malawi_constituencies_projects_spatial<-malawi_constituencies_projects_spatial %>% 
                                        replace_na(list(sum_projects=0)) %>% 
                                        relocate(ID, sum_projects)
```

Now, if we open up the dataset, everything should look in order:

```{r}
View(malawi_constituencies_projects_spatial)
```

```{r, echo=F}
malawi_constituencies_projects_spatial %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

We have a constituency-level dataset containing information on the number of WB foreign aid project sites within each constituency, which was acquired via the spatial join. This information could be used, for example, in a constituency-level analysis of the political or economic implications of WB project sites. 

# Manipulating Vector Data

In addition to using GIS tools to analyze vector datasets in terms of their spatial relations, we can also manipulate or transform vector datasets for purposes of visualization or analysis. This section considers some of these common vector data operations. 

## Combining vector datasets

In the examples above, we layered distinct spatial datasets on top of each other. We can also situate distinct datasets next to each other. Let's consider an example closer to home. 

The code below 

```{r}
CO_census_tracts<-get_decennial(geography = "tract",
                           state="CO",
                           variables = "P001001",
                           year = 2010,
                           geometry=TRUE) %>% 
                      st_transform(4326)
```

```{r}
tm_shape(CO_census_tracts)+
  tm_polygons()
```

```{r}
newmexico_counties<-get_decennial(geography = "county",
                           state="NM",
                           variables = "P001001",
                           year = 2010,
                           geometry=TRUE) %>% 
                      st_transform(4326)
```

```{r}
tm_shape(newmexico_counties)+
  tm_polygons()
```

```{r}
tm_shape(CO_census_tracts)+
  tm_polygons()+
tm_shape(newmexico_counties)+
  tm_polygons()
```

```{r}
co_mex_bbox<-st_bbox(c(xmin=-109.0603, xmax=-102.0415, ymin=31.3323, ymax=41.00344))
```

```{r}
tm_shape(CO_census_tracts, bbox=co_mex_bbox)+
  tm_polygons()+
tm_shape(newmexico_counties)+
  tm_polygons()
```

```{r}
CO_NM_combined<-rbind(CO_census_tracts, newmexico_counties)
```

```{r}
tm_shape(CO_NM_combined)+
  tm_polygons()
```

## Dissolving vector datasets

```{r, message=F, results=F, warning=F}
# extract state population data from 2010 census
usa_state_boundaries<-get_decennial(geography = "state", 
                                     variables = "P001001",
                                     year = 2010,
                                     geometry=TRUE)
```

```{r}
# Visualize state polygons
tm_shape(usa_state_boundaries)+
  tm_polygons()
```

```{r}
# Remove Alaska, Hawaii, and Puerto Rico so that we only have continental USA
continental_USA<-usa_state_boundaries %>% 
                  filter(GEOID!="02" & GEOID!="15" & GEOID!="72")
```

```{r}
# Visualize continental USA polygons
tm_shape(continental_USA)+
  tm_polygons()
```


```{r}
# Define regional groups
continental_USA_regions<-continental_USA %>% 
  mutate(region=case_when(
    (GEOID=="09"|GEOID=="23"|GEOID=="25"|GEOID=="33"|GEOID=="44"|
       GEOID=="50")~"New England",
    (GEOID=="10"|GEOID=="11"|GEOID=="24"|GEOID=="34"|
       GEOID=="36"|GEOID=="42")~"Mideast",
    (GEOID=="17"|GEOID=="18"|GEOID=="26"|GEOID=="39"|GEOID=="55")~
      "Great Lakes",
    (GEOID=="19"|GEOID=="20"|GEOID=="27"|GEOID==29|GEOID=="31"|
       GEOID=="38"|GEOID=="46")~"Plains",
    (GEOID=="01"|GEOID=="05"|GEOID=="12"|GEOID=="13"|
       GEOID=="21"|GEOID=="22"|GEOID=="28"|GEOID=="37"|
       GEOID=="45"|GEOID=="47"|GEOID=="51"|GEOID=="54")~"Southeast",
    (GEOID=="04"|GEOID=="35"|GEOID=="40"|GEOID=="48")~"Southwest",
    (GEOID=="08"|GEOID=="16"|GEOID=="30"|GEOID=="49"|
       GEOID=="56")~"Rocky Mountain",
    (GEOID=="06"|GEOID=="32"|GEOID=="41"|GEOID=="53")~"Far West"))
```

```{r}
# Project "continental_USA_regions"
continental_USA_regions_projected<-st_transform(continental_USA_regions, 5070)
```

```{r}
continental_USA_regions_projected
```

```{r}
continental_usa_dissolve<-continental_USA_regions_projected %>% 
                              group_by(region) %>% 
                              summarise()
```

```{r}
tm_shape(continental_usa_dissolve)+
  tm_polygons()
```

https://guides.library.duke.edu/r-geospatial/CRS
https://mgimond.github.io/Spatial/vector-operations-in-r.html

# Clipping polygons

```{r}
arbitrary_bounding_box<-
  st_bbox(c(xmin=500000, xmax=1000000, ymin=1100000, ymax=2000000)) %>% 
    st_as_sfc() %>% 
    st_set_crs(5070)
```

```{r}
tm_shape(continental_USA_regions_projected)+
  tm_polygons()+
tm_shape(arbitrary_bounding_box)+
  tm_polygons(alpha=0, lwd=5)
```

```{r}
states_bounding_box_intersection<-st_intersection(continental_USA_regions_projected, arbitrary_bounding_box)
```

```{r}
tm_shape(states_bounding_box_intersection)+
  tm_polygons()
```

```{r}
states_bounding_box_intersect<-
  continental_USA_regions_projected %>% 
          st_filter(arbitrary_bounding_box, .predicate=st_intersects)
```

```{r}
tm_shape(states_bounding_box_intersect)+
  tm_polygons()
```

## Union 

```{r}
arbitrary_bounding_box<-
  st_bbox(c(xmin=500000, xmax=1000000, ymin=1100000, ymax=2000000)) %>% 
    st_as_sfc() %>% 
    st_set_crs(5070)
```

```{r}
arbitrary_bounding_box_two<-
    st_bbox(c(xmin=75000, xmax=930000, ymin=1300000, ymax=2100000)) %>% 
    st_as_sfc() %>% 
    st_set_crs(5070)
```


```{r}
tm_shape(continental_USA_regions_projected)+
  tm_polygons()+
tm_shape(arbitrary_bounding_box)+
  tm_borders(lwd=5)+
tm_shape(arbitrary_bounding_box_two)+
  tm_borders("red", lwd=5)
```

```{r}
bounding_box_union<-st_union(arbitrary_bounding_box, arbitrary_bounding_box_two)
```

```{r}
tm_shape(continental_USA_regions_projected)+
  tm_polygons()+
tm_shape(bounding_box_union)+
  tm_borders(lwd=5)
```

```{r}
bounding_box_intersection<-st_intersection(arbitrary_bounding_box, arbitrary_bounding_box_two)
```

```{r}
tm_shape(continental_USA_regions_projected)+
  tm_polygons()+
tm_shape(bounding_box_intersection)+
  tm_borders(lwd=5)
```

## Inverse clip/Erase

```{r}
states_bounding_box_inverse<-st_difference(continental_USA_regions_projected, arbitrary_bounding_box)
```

```{r}
tm_shape(states_bounding_box_inverse)+
  tm_polygons()
```

https://cran.r-project.org/web/packages/sf/vignettes/sf4.html
https://www.r-bloggers.com/2014/07/clipping-spatial-data-in-r/
https://mgimond.github.io/Spatial/vector-operations-in-r.html#clipping-spatial-objects-using-other-spatial-objects

# Geocoding

```{r}
CO_epa<-read_csv("https://www.dropbox.com/s/43pcrmvhs0dqcwv/STATE_SINGLE_CO.CSV?dl=1")
```

```{r}
CO_epa_boulder<-CO_epa %>% filter(COUNTY_NAME=="BOULDER")
```

```{r, eval=F}
CO_epa_boulder_geocoded_census<-CO_epa_boulder %>% 
                            geocode(street=LOCATION_ADDRESS, city=CITY_NAME, postalcode = POSTAL_CODE, state=STATE_NAME, limit=1, method="census", full_results=TRUE)
```

```{r, echo=F, warning=F, message=F}
CO_epa_boulder_geocoded_census<-read_csv("class_notes/class2/data/geocoded_dataset.csv")
```

```{r}
CO_epa_boulder_points<-CO_epa_boulder_geocoded_census %>% 
                        drop_na(long) %>% 
                        st_as_sf(coords=c("long", "lat"), crs=4326)
```

```{r, message=F, warning=F, results=F}
CO_counties<-get_decennial(geography = "county",
                           state="CO",
                           variables = "P001001",
                           year = 2010,
                           geometry=TRUE) %>% 
                      st_transform(4326)
```

```{r}
tm_shape(CO_counties)+
  tm_polygons()+
tm_shape(CO_epa_boulder_points)+
  tm_dots()
```

```{r}
boulder_county<-CO_counties %>% 
                  filter(GEOID=="08013")
```

```{r}
tm_shape(boulder_county)+
  tm_polygons()+
tm_shape(CO_epa_boulder_points)+
  tm_dots("orange")
```

```{r}
boulder_county_projected<-st_transform(boulder_county, 2231)
CO_epa_boulder_points_projected<-st_transform(CO_epa_boulder_points, 2231)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(CO_epa_boulder_points_projected)+
  tm_dots("orange")
```

```{r}
CO_epa_boulder_points_cleaned<-
  CO_epa_boulder_points_projected %>% 
    st_filter(boulder_county_projected, .predicate=st_intersects)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(CO_epa_boulder_points_cleaned)+
  tm_dots("orange")
```

# Distance and Area

## Load data 
```{r, echo=-11}
setwd("class_notes/class2/data")
download.file(url="https://geo.colorado.edu/apps/geolibrary/datasets/caiHospitals.zip", destfile="hospitals.zip")

unzip(zipfile = "hospitals.zip")

hospital_points<-st_read(dsn="CAI_Hospitals.shp")
```

```{r}
hospital_points
```

```{r}
tm_shape(CO_counties)+
  tm_polygons()+
tm_shape(hospital_points)+
  tm_dots()
```


```{r}
boulder_hospitals<-hospital_points %>% 
                    filter(STCTYFIPS=="08013") %>% 
                    st_transform(2231)
```


```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(boulder_hospitals)+
  tm_dots()
```

## Extracting distances based on a single dataset

```{r}
boulder_hospital_distancematrix<-st_distance(boulder_hospitals)
```

```{r}
boulder_hospital_distancematrix
```

```{r}
rownames(boulder_hospital_distancematrix)<-boulder_hospitals$NAME
colnames(boulder_hospital_distancematrix)<-boulder_hospitals$NAME

boulder_hospital_distancematrix
```

```{r}
boulder_hospital_distancematrix["Longmont United Hospital", "Boulder Community Hospital"]
```

## Extracting distances between features in different datasets

[fire stations](https://opendata-bouldercounty.hub.arcgis.com/datasets/bouldercounty::fire-stations/about)

```{r, echo=-1}
setwd("class_notes/class2/data/fire_stations")
boulder_fire_stations<-st_read("Fire_Stations.shp")
```

```{r}
boulder_fire_stations
```

```{r}
boulder_fire_stations_projected<-boulder_fire_stations %>%  
                                    st_transform(2231)
```

```{r}
boulder_hospital_firstation_distancematrix<-
  st_distance(boulder_hospitals, boulder_fire_stations_projected)
```

```{r}
firestations_hospitals<-
  tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(boulder_fire_stations_projected)+
  tm_dots("red", size=0.1)+
tm_shape(boulder_hospitals)+
  tm_dots("blue", size=0.1)

firestations_hospitals
```

```{r}
rownames(boulder_hospital_firstation_distancematrix)<-boulder_hospitals$NAME
colnames(boulder_hospital_firstation_distancematrix)<-boulder_fire_stations_projected$Station_Na

boulder_hospital_firstation_distancematrix
```

```{r, echo=F}
boulder_hospital_firstation_distancematrix %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 1)

))
```

```{r}
boulder_hospital_firstation_distancematrix["Boulder Medical Center", "Nederland Station 2"]
```

```{r}
boulder_hospital_firstation_distancematrix_df<-as.data.frame(boulder_hospital_firstation_distancematrix)
```

```{r}
# distance to closest fire station for each hospital
apply(boulder_hospital_firstation_distancematrix_df, 1, FUN=min)
```

```{r}
# distance to closest hospital for each fire station
apply(boulder_hospital_firstation_distancematrix_df, 2, FUN=min)
```

## Extracting areas

```{r}
# extracts area of Boulder county
boulder_area<-st_area(boulder_county_projected)
```

```{r}
boulder_area
```

```{r}
boulder_area_km<-set_units(boulder_area, "km^2")
```

```{r}
CO_tracts<-get_decennial(geography = "tract",
                           state="CO",
                           variables = "P001001",
                           year = 2010,
                           geometry=TRUE) %>% 
                      st_transform(2231)
```

```{r}
tm_shape(CO_tracts)+
  tm_polygons()
```

```{r}
boulder_tracts<-CO_tracts %>% 
                  st_filter(boulder_county_projected, .predicate=st_intersects)
```


```{r}
tm_shape(boulder_tracts)+
  tm_polygons()+
tm_shape(boulder_county_projected)+
  tm_polygons("red", alpha=0.5)
```


```{r}
boulder_tracts
```

```{r}
# Turn off scientific notation
options(scipen = 100)

boulder_tract_areas<-boulder_tracts %>% 
                      mutate(area=st_area(boulder_tracts))

```

```{r}
units(boulder_tract_areas$area)<-"km^2"
```

```{r}
boulder_tract_areas
```


# Distance Buffers

https://geodacenter.github.io/opioid-environment-toolkit/buffer_analysis.html

```{r}
firestations_hospitals
```

```{r}
hospital_buffers<-st_buffer(boulder_hospitals, dist=5280)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(boulder_hospitals)+
  tm_dots("blue")+
tm_shape(hospital_buffers)+
  tm_borders(alpha=0.5, "blue", lwd=3)
```

```{r}
fire_station_buffers<-st_buffer(boulder_fire_stations_projected, dist=5280)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(boulder_fire_stations_projected)+
  tm_dots("red")+
tm_shape(fire_station_buffers)+
  tm_borders(alpha=0.5, "red", lwd=3)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(boulder_fire_stations_projected)+
  tm_dots("red")+
tm_shape(fire_station_buffers)+
  tm_borders(alpha=0.5, "red", lwd=3)+
tm_shape(boulder_hospitals)+
  tm_dots("blue")+
tm_shape(hospital_buffers)+
  tm_borders(alpha=0.5, "blue", lwd=3)
```

```{r}
hospital_firestation_intersection<-st_intersection(hospital_buffers, fire_station_buffers)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(hospital_firestation_intersection)+
  tm_polygons("orange")
```


```{r}
hospital_firestation_intersection_dissolve<-hospital_firestation_intersection %>% 
                                            group_by() %>% 
                                            summarise()
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(hospital_firestation_intersection_dissolve)+
  tm_polygons("orange")
```

```{r}
fire_hospital_intersection_area<-st_area(hospital_firestation_intersection_dissolve)
```

```{r}
fire_hospital_intersection_area
```

```{r}
fire_hospital_intersection_area_sqmiles<-set_units(fire_hospital_intersection_area, "miles^2")

fire_hospital_intersection_area_sqmiles
```

15.83 sq miles within Boulder County is within 1 mile of both a fire station AND a hospital

```{r}
hospital_firestation_union<-st_union(hospital_buffers, fire_station_buffers)
```

```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(hospital_firestation_union)+
  tm_polygons("gold")
```

```{r}
hospital_firestation_union_dissolve<-hospital_firestation_union %>% 
                                            group_by() %>% 
                                            summarise()
```


```{r}
tm_shape(boulder_county_projected)+
  tm_polygons()+
tm_shape(hospital_firestation_union_dissolve)+
  tm_polygons("gold")
```


```{r}
hospital_firestation_union_area<-st_area(hospital_firestation_union_dissolve)

hospital_firestation_union_area
```

```{r}
hospital_firestation_union_area_sqmiles<-set_units(hospital_firestation_union_area, "miles^2")

hospital_firestation_union_area_sqmiles
```

257 miles are within 1 mile of a fire station OR hospital



continental_usa_dissolve<-continental_USA_regions_projected %>% 
                              group_by(region) %>% 
                              summarise()

https://geobgu.xyz/r/geometric-operations-with-vector-layers.html#distance


https://towardsdatascience.com/breaking-down-geocoding-in-r-a-complete-guide-1d0f8acd0d4b
https://cran.r-project.org/web/packages/tidygeocoder/vignettes/tidygeocoder.html


https://www.epa.gov/frs/epa-frs-facilities-state-single-file-csv-download
https://www.epa.gov/frs/geospatial-data-download-service


geocoding
buffer
spatial join
intersect/union/overlap
distance calculations
area calculations
coordinate systems 

https://www.epa.gov/frs/epa-frs-facilities-state-single-file-csv-download

latlong: https://www.britannica.com/science/latitude

https://philmikejones.me/tutorials/2015-09-03-dissolve-polygons-in-r.html

https://geobgu.xyz/r/geometric-operations-with-vector-layers.html

https://github.com/r-spatial/sf/issues/290 

https://mgimond.github.io/Spatial/vector-operations-in-r.html

http://learnline.cdu.edu.au/units/ses101/env208/w5_files/GeoprocessingTools_handouts.pdf

https://www.r-bloggers.com/2014/07/clipping-spatial-data-in-r/



superfund dataset: https://dataverse.unc.edu/dataset.xhtml?persistentId=doi:10.15139/S3/4QEIGO

https://glenbambrick.com/tag/map-projections/

https://walker-data.com/census-r/spatial-analysis-with-us-census-data.html

https://stackoverflow.com/questions/62442150/why-use-st-intersection-rather-than-st-intersects

http://www.wvview.org/spatial_analytics/Visualizing_Spatial_Data/_site/Visualize_Spatial_Data.html

https://datacornering.com/remove-scientific-notation-in-r/
