---
title: "Scripting Tools for GIS"
author: "Aditya Ranganath"
date: "4/10/2022"
output: 
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=F, warning=F, results=F}
library(WDI)
library(sf)
library(tmap)
library(rnaturalearth)
library(rnaturalearthdata)
library(tidyverse)
library(tidycensus)
library(raster)
library(exactextractr)
library(terra)
```

```{r, echo=F, warning=F, message=F}
library(DT) 
```

```{r, echo=F, warning=F, message=F}
tmap_mode("plot")
```

# Introduction

In the course of working on a GIS project, you may have to perform certain tasks multiple times. For example, you may want to implement a spatial join (a procedure we learned about last class) between a point layer and several different polygon datasets that reflect different geographic scales. Or, you may want to quickly make multiple maps, to get a sense of how different variables are distributed across space before beginning a more in-depth study. 

Dedicated GIS applications like ArcGIS and QGIS have built-in scripting windows that allow users to write Python scripts that can automate repetitive procedures. In addition, for users unfamiliar with Python, ArcGIS provides tools like Model Builder, and embeds batch-processing functions embedded in its menu-bused interface. 

In this lesson, we'll become familiar with some basic scripting tools that can help you to automate some of the tasks we have already covered in the course with a minimal amount of programming. These tools will come in handy if you decide to work with GIS in a longer-term project and you want to save time on your geoprocessing tasks. 

# Functions and Iteration

Before diving into some GIS-specific examples, let's become familiar with some basic concepts and processes using a simple example. This section demonstrates how to write a basic function with a single argument/input, and then iteratively pass several different arguments to that function.

## Writing functions with a single argument: A simple (non-GIS) example

Let's say you have a large collection of temperature data, measured in Fahrenheit, and you want to convert these data to Celsius. Recall that the formula to convert between Fahrenheit and Celsius is as follows: 

```{r}
# fahrenheit to Celsius formula, where "F" is fahrenheit input
(F-32)*(5/9)
```

At its most basic level, R is a calculator; if for example, one of our Fahrenheit measurements is 55 degrees; we can convert this to Celsius by plugging 55 into the conversion formula:

```{r}
# Converts 55 degrees fahrenheit to Celsius
(55-32)*(5/9)
```

This is easy enough, but if we have a large amount of temperature data that requires processing, we wouldn't want to carry out this calculation for each measurement in our data collection. The first step in allowing us to carry out this conversion operation at scale is to write a function, which is simply a programming construct that takes a set of inputs (also known as arguments), manipulates those inputs/arguments in a specific way (the body of the function), and returns an output that is the product of how those inputs are manipulated in the body of the function. It is much like a recipe, where the recipe's ingredients are analogous to a function's inputs, the instructions about how to combine and process those ingredients are analogous to the body of the function, and the end product of the recipe (for example, a cake) is analogous to the function's output. 

Let's see how we can wrap the Fahrenheit-Celsius formula above into a function:

```{r}
fahrenheit_to_celsius_converter<-function(fahrenheit_input){
  celsius_output<-(fahrenheit_input-32)*(5/9)
  return(celsius_output)
}
```

Let's unpack the code above, which we used to create our function:

* We declare that we are creating a new function with the word ```function```; within the parenthesis after ```function```, we specify the function's argument(s). Here, the function's argument is an input named ```fahrenheit_input```. The name of the argument(s) is arbitrary, and can be anything you like; ideally, its name should be informed by relevant context. Here, the argument/input to the function is a temperature value expressed in degrees Fahrenheit, so the name "fahrenheit_input" describes the nature of this input. 
* After enclosing the function's arguments within parentheses, we print a right-facing curly brace ```{```, and then define the body of the function (i.e. the recipe), which specifies how we want to transform this input. In particular, we take ```fahrenheit_input```, subtract 32, and then multiply by 5/9, which transform the input to the celsius temperature scale. We'll tell R to assign this transformed value to a new object, named ```celsius_output```. 
* In the function's final line, ```return(celsius_output)```, we specify the value we want the function to return. Here, we are saying that we want the function to return the value that was assigned to ```celsius_output```. We then close the function by typing a left-facing curly brace below the return statement ```}```.
* Just as we can assign data or visualizations to objects that allow us to subsequently retrieve the outputs of our code, so too with functions. Here, we'll assign the function we have just return to an object named ```fahrenheit_to_celsius_converter```. 

After running that code, we can use the newly created ```fahrenheit_to_celsius``` function to perform our Fahrenheit to Celsius transformations. Let's say we have a Fahrenheit value of 68, and want to transform it to Celsius: 

```{r}
fahrenheit_to_celsius_converter(fahrenheit_input=68)
```

Above, we passed the argument "fahrenheit_input=68" to the ```fahrenheit_to_celsius_converter``` function that we created; the function then took this value (68), plugged it into "fahrenheit_input" within the function and assigned the resulting value to "celsius_output"; it then returned the value of "celsius_output" (20) back to us. 

Let's try another one: 

```{r}
fahrenheit_to_celsius_converter(fahrenheit_input=22)
```

In short, we can specify any value for the "fahrenheit_input" argument; this value will be substituted for "fahrenheit_input" in the expression ```celsius_output<-(fahrenheit_input-32)*(5/9)```, after which the value of ```celsius_output``` will be returned to us. 

## Iteration with a single-input function

Using this newly created function helps us to avoid manually converting each of our temperature values from the Fahrenheit scale to the Celsius scale; instead of repeating the calculation over and over manually, we could simply plug our Fahrenheit temperature values into the function, and let the function carry out the calculation for us. However, it is still time-consuming to plug our Fahrenheit values into the function one-by-one. For example, let's say we have a vector of Fahrenheit temperature values; below, we'll assign these values to an object named ```fahrenheit_input_vector```: 

```{r}
fahrenheit_input_vector<-c(45.6, 95.9, 67.8, 43)
```

If we wanted to convert all of these Fahrenheit values to the Celsius scale, we could do so individually, i.e. 

```{r}
fahrenheit_to_celsius_converter(fahrenheit_input=45.6)
```

And so on. 

However, we can also iteratively apply our function to all of these vector elements, and deposit the transformed results into a new vector.  In programming languages, functions are typically applied to multiple inputs in an iterative fashion using a construct known as a for-loop, which some of you may already be familiar with. R users also frequently use specialized functions (instead of for-loops) to iterate over elements; this is often faster, or at the very least, makes R scripts more readable. One family of these iterative functions is the "Apply" family of functions. A more recent set of functions that facilitate iteration is part of the *tidyverse*, and is found within the [purrr](https://purrr.tidyverse.org/) package. These functions known as ```map()``` functions, and we will use them here to iteratively apply our functions to multiple inputs (the "map" label might be confusing when working in a GIS setting where you might be making actual maps, i.e. spatial visualizations; however, it should be clear from the context whether we are referring to ```map()``` functions within *purrr*, or to actual maps). 

Let's see how we can use a ```map()``` function to sequentially apply the ```fahrenheit_to_celsius_converter()``` function we created to several different values for the "fahrenheit_input" argument, contained in ```fahrenheit_input_vector```. We'll pass ```fahrenheit_input_vector``` as the first argument to the  ```map_dbl()``` function, and ```fahrenheit_to_celsius_converter``` (i.e. the function we want to apply iteratively to the elements in `the```fahrenheit_input_vector``` ) as the second argument. The result of this operation will be a new "results vector", containing the transformed temperature values for each input in the original vector of Fahrenheit values (```fahrenheit_input_vector```). We'll assign this result/output vector to a new object named ```celsius_outputs_vector```: 

```{r}
celsius_outputs_vector<-map_dbl(fahrenheit_input_vector, fahrenheit_to_celsius_converter)
```

In short, the code above takes ``fahrenheit_input_vector``` (i.e. a vector with the numbers 45.6, 95.9, 67.8, 43), and runs each of these numbers through the ```fahrenheit_converter()``` function, and sequentially deposits the transformed result to the newly created ```celsius_outputs_vector()``` object, which contains the following elements:

```{r}
celsius_outputs_vector
```

More explicitly, the code that reads ```celsius_outputs_vector<-map_dbl(fahrenheit_input_vector, fahrenheit_converter)``` did the following:

1. Pass 45.6 (the first element in the input vector, ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and place the output (7.555556) as the first element in a new vector of transformed values, named ```celsius_outputs_vector```.
2. Pass 95.9 (the second element in the input vector, ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and deposit the output (35.500000) as the second element in ```celsius_outputs_vector```. 
3. Pass 67.8 (the third element in the input vector,  ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and deposit the output (19.888889) as the third element in ```celsius_outputs_vector```. 
4. Pass 43 (the fourth element in the input vector, ```fahrenheit_input_vector```) to the ```fahrenheit_converter()``` function, and deposit the output (6.111111) as the fourth element in ```celsius_outputs_vector```. 

If we want to extract an element from the output vector, we can do so by specifying its index within brackets. For instance, if we wanted to extract the second element in ```celsius_outputs_vector```, we could type the following:

```{r}
celsius_outputs_vector[2]
```

There are a variety of map functions, and the precise one you should use turns on the number of arguments used by the function (here, this value is of course one), and the desired class of the output (i.e. numeric vector, character vector, data frame, list etc.). Below, we'll talk more about how to handle functions with multiple arguments within the *purrr* ecosystem. Before that, though, let's see how to use a slightly different type of *map* function to return a different kind of output.

First, let's say we want to iteratively pass the input values from ```fahrenheit_input_vector``` as arguments to ```fahrenheit_converter()```, but that we want to return the output values in a list, rather than a vector (as above). To do so, we pass  our input vector (```fahrenheit_input_vector```),  and the function we want to iteratively apply to the elements of the input vector (```fahrenheit_converter```) to the ```map()``` function. We'll assign the output list to a new object named ```celsius_outputs_list```: 

```{r}
celsius_outputs_list<-map(fahrenheit_input_vector, fahrenheit_to_celsius_converter)
```

Let's now print the contents of our list; note that each of our transformed Celsius temperature values is now a separate list element within ```celsius_outputs_list```:

```{r}
celsius_outputs_list
```

We can extract specific list elements by specifying the index number of the list element in double-brackets after the name of the list object (note that this is slightly different from extracting the element of a numeric vector, for which we use a single bracket, as demonstrated earlier). For example, if we want to extract the second element of ```celsius_outputs_list```, we can use the following: 

```{r}
celsius_outputs_list[[2]]
```

A handy *tidyverse* function, called ```pluck()``` can also be used to extract list elements; for example, we can extract the second list element from ```celsius_outputs_list``` with ```pluck()``` with the following:

```{r}
celsius_outputs_list %>% pluck(2)
```

If we want to organize our information in a data frame, the first step is to  slightly modify our function to return a data frame:

```{r}
fahrenheit_to_celsius_converter_df<-function(fahrenheit_input){
  celsius_output<-(fahrenheit_input-32)*(5/9)
  celsius_output_df<-as.data.frame(cbind(fahrenheit_input, celsius_output))
  return(celsius_output_df)
}
```

Now, let's test this function for a single value:

```{r}
fahrenheit_to_celsius_converter_df(44)
```

Let's say we want to assemble a dataset using multiple Fahrenheit input values, where one column consists of these input values, and the second column consists of the corresponding Celsius outputs? To that end, we can use the ```map_dfr()``` function, which is part of the *purrr* package's suite of ```map()``` functions. Below, we'll use the same ```fahrenheit_input_vector``` from above as our input vector, and pass this vector as the first argument to the ```map_dfr()``` function; the second argument is the name of the function to which we want to apply these input values, namely, ```fahrenheit_to_celsius_converter_df()```. We'll assign the dataset to an object named ```celsius_outputs_df```:

```{r}
celsius_outputs_df<-map_dfr(fahrenheit_input_vector, fahrenheit_to_celsius_converter_df)
```

Let's now print the contents of ```celsius_outputs_df```:

```{r}
celsius_outputs_df
```

We now have a dataset with one column consisting of our Fahrenheit inputs (taken from ```fahrenheit_input_vector```), and a second column consisting of our Celsius outputs (derived by applying the ```fahrenheit_to_celsius_converter_df()``` function to our vector of input values, ````fahrenheit_input_vector```). 

We've just covered three different *purrr* functions: ```map()``` (which returns a list), ```map_dbl()``` (which returns a vector), and ```map_dfr()``` (which returns a dataframe). There are other map functions which return different types of objects; you can see a list of these other map functions by inspecting the documentation for the ```map()``` function with ```?purrr::map()```.

## Iteration with functions that have two inputs

In the previous subsection, we explored some basic functions from the *purrr* package's ```map()``` family, which are used to iteratively apply a given function to a set of inputs, and then return a set of outputs (i.e. the results of applying that function) that is contained in an object (the type of object, i.e. list, vector etc. is determined by the type of *map* function that is used). The functions we were iteratively applying in the examples above were single-input functions, but functions can (and often do) require multiple inputs. 

In this subsection, we'll explore iteration with ```map2()``` functions, which are used for iteration in cases where the relevant function has two inputs. First, let's define a simple 2-input function. In this example, we'll define a function that takes export and import values as inputs, and returns a value for net exports (defined as the difference between total exports and total imports), and assign the function to an object named ```net_exports_calculation()```:

```{r}
net_exports_calculation<-function(exports, imports){
  net_export_value<-exports-imports
  return(net_export_value)
}
```

Let's now test the function for a single case, with arbitrary input values, denominated in units of $1  million. We'll test the function for a hypothetical case where exports are $133 million (exports=133) and imports are $55 million (imports=55): 

```{r}
net_exports_calculation(exports=133, imports=55)
```

The function, as expected, returns a net export value of $78 million. 

Now, let's say we have export and import data for several countries, and want to calculate net exports for all of these countries by iteratively applying ```net_exports_calculation()``` to all of our data. The first country has exports of $78 million and imports of $134 million; the second has exports of $499 million and imports of $345 million; and the third country has exports of $785 million  and imports of $645 million. How can we apply ```net_exports_calculation()``` to each of these countries, and calculate a net export value for each one?

First, we'll create vectors that contain our import and export values. Below, a numeric vector containing each country's export values is assigned to an object named ```export_vector```, and a numeric vector containing each country's import values is assigned to an object named ```import_vector```:

```{r}
export_vector<-c(78, 499, 785)
import_vector<-c(134, 345, 645)
```

Now, let's cycle these vectors through the ```net_exports_calculation()```` function, and deposit the resulting export values into a list, which we'll name ```net_export_list```. Instead of using the ```map()``` function (as above), we'll use a function named ```map2()```, since the function we're applying has two inputs. 

Below, the first argument to ```map2()```, ```export_vector````, is the vector we defined above which contains our export values; the second argument, ```import_vector```, is our vector of import values; and the third argument, ```net_exports_calculation```, is the function we want to apply. 

The ```map2()``` function will take the first  element of ```export_vector``` and the first element of ```import_vector```, run those values through ```net_exports_calculation```, and deposit the result (i.e. the net export value for the first country) as the first element in the ```net_export_list``` list object. Then, it will take the second  element of ```export_vector``` and the second element of ```import_vector```, run those values through ```net_exports_calculation```, and deposit the result (i.e. the net export value for the first country) as the second element in the ```net_export_list``` list object. Finally, it will go through the same process for the third country. 

```{r}
net_export_list<-map2(export_vector, import_vector, net_exports_calculation)
```

Let's now print the contents of ```net_export_list```, which contain our net export values:

```{r}
net_export_list
```

If, instead of depositing the results into a list, we'd like to deposit our outputs into a numeric vector, we can do so using the ```map2_dbl()``` function, the analog of ```map_dbl()``` which is used when the function takes two inputs rather than one. We'll assign our results vector to a new object named ```net_export_vector```:

```{r}
net_export_vector<-map2_dbl(export_vector, import_vector, net_exports_calculation)
```

Let's now print the contents of ```net_export_vector```:

```{r}
net_export_vector
```

Note that the net export values contained in ```net_export_vector``` are the same as those in ```net_export_list```, as we would expect; the only difference is that ```net_export_vector``` is a vector and ```net_export_list``` is a list. 

Just as ```map2()``` and ```map2_dbl()``` serve as analogs to ```map()``` and ```map_dbl()``` for functions with two inputs, ```map2_dfr()``` is the analog to ```map_dfr()``` for such functions. To see how it works, let's first define a function that returns a dataframe, with the first column consisting of the export value, the second consisting of the import value, and the final column consisting of the net export value that is calculated within the body of the function. We'll assign this function to a new object named ```net_exports_calculation_df()```: 

```{r}
net_exports_calculation_df<-function(exports, imports){
  net_exports<-exports-imports
  df<-as.data.frame(cbind(exports, imports, net_exports))
  return(df)
}
```

Now, let's test the ```net_exports_calculation_df()``` function we've just defined using an export value of $100 millions (exports=100) and an import value of $40 million (imports=40 million): 

```{r}
net_exports_calculation_df(exports=100,imports=40)
```

Having confirmed that the function works as expected, let's use the ```map2_dfr()``` function to iteratively apply the ```net_exports_calculation_df()``` function to the export values contained in ```export_vector``` and the import values contained in ```import_vector```. 

The code below takes the first element in ```export_vector```, and the first element in ```import_vector```, and runs these input values through ```net_exports_calculation_df()``` to create the first row of the output data frame (where the first column is the first element of ```export_vector```, the second column is the first element of ```import_vector```, and the third column is the net export value calculated using these values). It then takes the second element in ```export_vector```, and the second element in ```import_vector```, and runs these input values through the ```net_exports_calculation_df()``` function to create the second row of the output data frame. Finally, it repeats the process for the third elements of ```export_vector``` and  ```export_vector```, and creates the third row of the output data frame. We'll assign the data frame to a new object named ```net_exports_dataframe```:

```{r}
net_exports_dataframe<-map2_dfr(export_vector, import_vector, net_exports_calculation_df)
```

Let's now print the contents of our newly created data frame object:

```{r}
net_exports_dataframe
```

## Iteration with functions that have more than two inputs

While the ```map2()``` family functions allows us to conveniently handle iteration tasks involving two-input functions, you will often need to work with functions with more than two inputs. How can we carry out iteration tasks with these multi-input functions? 

The ```pmap()``` family of functions within *purrr* allows us to handle iteration tasks using functions with any number of inputs greater than two, by using a list as a container for all of the inputs we would like to iterate over. 

To see how this works, let's first define a function with more than two arguments. In particular, we'll create a function that takes numeric values for consumption spending (consumption_spending), government spending (government_spending), investment spending (investment_spending), and net exports (net_exports) as arguments, and returns a value for GDP (which is the sum of these values). We'll assign this GDP calculator function to a new object named ```gdp_calculation```:

```{r}
gdp_calculation<-function(consumption_spending, government_spending, investment_spending, net_exports){
  gdp<-consumption_spending+government_spending+investment_spending+net_exports
  return(gdp)
}
```

Let's now test the function; as before, we'll assume that units are in millions of dollars. We'll test our function for a country with consumption spending of $125 million (```consumption_spending=125```), government spending of $66 million (```government_spending=66```), investment spending of $36 million (```investment_spending=36```), and net exports of -$33 million (```net_exports=-33```): 

```{r}
gdp_calculation(consumption_spending = 125, government_spending=66, investment_spending=36, net_exports=-33)
```

As expected, the function returns the sum of these values, which translates into 194 (interpreted here as a GDP of $194 million). 

Now, let's say we have consumption spending, government spending, investment spending, and net export data for four different countries, and we want to iteratively apply the ```gdp_calculation()``` function over the data for these four countries, and then deposit the resulting GDP values for each of the countries into a list. 

The first step is to create a new list of input values, where each list element is a vector that contains the country-level values for each argument of the ```gdp_calculation()``` function. We'll assign this list to a new object named ```gdp_input_list```:

```{r}
gdp_input_list<-list(consumption_spending=c(44, 89, 64, 33),
                     government_spending=c(54, 76, 222, 110),
                     investment_spending=c(123, 200, 55, 45),
                     net_exports=c(-55, 89, 143,-12))
```

To make sure we understand what ```gdp_input_list``` represents, consider the first element in each of the four numeric vectors in the list; the first element corresponds to the first country, which we can see has consumption spending of $44 million, government spending of $54 million, investment spending of $123 million, and net exports of -$55 million. The second element of each of the vectors in the list corresponds to information for the second country, which has consumption spending of $89 million, government spending of $76 million, investment spending of $200 million, and net exports of $89 million. And so on for Countries 3 and 4. 

Now that we have defined our list of input values (```gdp_input_list```) based on the arguments to the ```gdp_calculation()``` function, we can pass ```gdp_input_list``` (the list of input values) and ```gdp_calculation()``` (the function we are iterating over) as arguments to *purrr's* ```pmap()``` function, which will iteratively apply the ```gdp_calculation()``` function to the inputs specified in ```gdp_input_list``` in a vectorized fashion (i.e. the function uses the first value in each vector of the input list to generate the first output value, and then uses the second value in each vector of the input list to generate the second output value etc). We'll assign the resulting list of output values to a new object named ```gdp_output_list```:

```{r}
gdp_output_list<-pmap(gdp_input_list, gdp_calculation)
```

Let's now print the contents of ```gdp_output_list```:

```{r}
gdp_output_list
```

As expected, the first list element contains the GDP of the first country, 166 (44+54+123+55); the second list element contains the GDP of the second country, 454 (89+76+200+89); and so on, for the third and fourth countries.

If we want our function outputs in a vector, rather than a list, we can simply use the ```pmap_dbl()``` function instead; below, we'll assign this vector of GDP values to an object named ```gdp_output_vector```:

```{r}
gdp_output_vector<-pmap_dbl(gdp_input_list, gdp_calculation)
```

When we print the contents of ```gdp_output_vector```, we can see the GDP values calculated by ```gdp_calculation()``` (based on the arguments specified in ```gdp_input_list```) within a vector:

```{r}
gdp_output_vector
```

As an exercise, see if you can write a function that takes arguments for consumption spending, government spending, investment spending, and net exports, and returns a data frame in which these values are columns, along with another column that contains the GDP value. Then, use the ```pmap_dfr()``` function to create a new dataframe using the input values contained in ```gdp_input_list``` (which we used above). 

```{r, echo=F, results=F}
gdp_calculation_df<-function(consumption_spending, government_spending, investment_spending, net_exports){
  gdp<-consumption_spending+government_spending+investment_spending+net_exports
  gdp_df<-as.data.frame(cbind(consumption_spending, government_spending, investment_spending, net_exports, gdp))
  return(gdp_df)
}

gdp_output_df<-pmap_dfr(gdp_input_list, gdp_calculation_df)
```

Your code should yield a table that looks something like this:

```{r, echo=F}
gdp_output_df
```

# Using functions and iteration in GIS workflows

## Functions, iteration, and spatial joins

In the second assignment, one of your options was to implement a spatial join using traffic stop data for the city of Aurora, compiled by the Stanford Open Policing Project. In particular, the assignment asked you to implement a spatial join with respect to census tracts, compute the total number of stops in each census tract, and then present this information in a data frame. 

The script below reviews the code that was required to carry out these tasks:  

```{r, results=F, eval=F, message=F}
# Reads in data and assigns to object named "CO_aurora_policestops"
CO_aurora_policestops<-read_csv("https://www.dropbox.com/s/u7xqa7dc34hlsfp/co_aurora_2020_04_01.csv?dl=1")

# Define spatial point object using "CO_aurora_policestops", and assign it to a new object named "co_aurora_sf"
co_aurora_sf<-CO_aurora_policestops %>% 
                  drop_na(lng) %>% 
                  st_as_sf(coords=c("lng", "lat"), crs=4326)

# Project "co_aurora_sf" into the appropriate projection for Aurora, and assign the reprojected data to an object named "co_aurora_sf_project"
co_aurora_sf_project<-co_aurora_sf %>% st_transform(2232)

# Extract census tract data for CO using tidycensus, and assign to a new object named "CO_tracts"
CO_tracts<-get_decennial(geography = "tract",
                         state="CO",
                         variables = "P001001",
                         year = 2010,
                         geometry=TRUE) %>% 
  st_transform(2232)

# Spatially join "CO_tracts" object to "co_aurora_sf_project" object, yielding a new dataset that contains information on the Census tract in which each stop occured; this new dataset is assigned to an object named "stops_tracts_join"
stops_tracts_join<-st_join(co_aurora_sf_project, CO_tracts)

# create a new dataframe containing information on the number of stops for each tract, and assign this data frame to an object named "stops_per_tract"
stops_per_tract<-stops_tracts_join %>% 
  group_by(GEOID, NAME) %>% 
  summarize(n())

# Renames column named "n()" to "traffic_stops
stops_per_tract_final<-stops_per_tract %>% 
                      rename(traffic_stops="n()")
```

```{r, echo=F, results=F, message=F}
# Reads in data and assigns to object named "CO_aurora_policestops"
CO_aurora_policestops<-read_csv("https://www.dropbox.com/s/u7xqa7dc34hlsfp/co_aurora_2020_04_01.csv?dl=1")

# Define spatial point object using "CO_aurora_policestops", and assign it to a new object named "co_aurora_sf"
co_aurora_sf<-CO_aurora_policestops %>% 
                  drop_na(lng) %>% 
                  st_as_sf(coords=c("lng", "lat"), crs=4326)

# Project "co_aurora_sf" into the appropriate projection for Aurora, and assign the reprojected data to an object named "co_aurora_sf_project"
co_aurora_sf_project<-co_aurora_sf %>% st_transform(2232)
```

Recall that the assignment also asked you to export the final dataset (here, the data assigned to ```stops_per_tract_final```) as a CSV file. The final CSV file will be less unwieldy if we transform ```stops_per_tract_final```, which is currently an *sf* object, into a dataframe object, and delete the "geometry" column. We can do so with the following:

```{r, results=F, eval=F, message=F}
# Converts "stops_per_tract_final" object to data frame, deletes "geometry" column, and assigns to a new object named "stops_per_tract_final_df"
stops_per_tract_final_df<-as.data.frame(stops_per_tract_final) %>% 
                          dplyr::select(-geometry)
```

Finally, we can export ```stops_per_tract_final_df``` to our working directory with the following:

```{r, results=F, eval=F, message=F}
write_csv(stops_per_tract_final_df, "census_tracts_stops.csv")
```

This script allowed us to generate and export a census tract-level dataset of police traffic stops, but let's say that we want to generate a dataset of traffic stops (using this data) at various other geographies as well (for instance, counties or county subdivisions or census blocks). One strategy to build these datasets at these different geographies is to simply use the script we developed for census tracts, copying and pasting relevant changes as necessary to adapt the code for different geographic boundaries.

A more efficient and scalable approach, however, is to wrap the code we developed into a function that takes a desired geography (from *tidycensus*) as an argument, and returns a dataset containing information on the number of stops per geographic unit (based on that desired geography). We'll use the same principles discussed in earlier sections to create this function, which generalizes the spatial join script for census tracts: 

```{r}
# Creates function that takes desired tidycensus geography as argument, and returns data frame of number of traffic stops with respect to that geography; function is assigned to an object named "traffic_stop_geography"
traffic_stop_geography<-function(desired_geography){

geography_extract<-get_decennial(geography = desired_geography,
                                   state="CO",
                                   variables = "P001001",
                                   year = 2010,
                                   geometry=TRUE) %>% 
                          st_transform(2232)
  
stop_geography_join<-st_join(co_aurora_sf_project, geography_extract)

stops_per_geography<-stop_geography_join %>% 
                            group_by(GEOID, NAME) %>% 
                            summarize(n()) %>% 
                            rename(traffic_stops="n()")

stops_per_geography_df<-as.data.frame(stops_per_geography) %>% 
                          dplyr::select(-geometry)

return(stops_per_geography_df)
}
```

Now that we have our function, let's go ahead and test it. Let's generate a dataset containing information on the number of stops within each county subdivision; we'll assign the dataset to an object named ```county_subdivision_stops```:

```{r, results=F, message=F}
county_subdivision_stops<-traffic_stop_geography(desired_geography="county subdivision")
```

Let's print the contents of ```county_subdivision_stops``` to see what our dataset looks like:

```{r, echo=F}
county_subdivision_stops %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Now, let's say we want to generate a county-level dataset of stops, a census tract level dataset of stops, and a zip code-level dataset of stops, and then place these datasets into a list. We can do so using the ```map()``` function we learned about earlier to iteratively apply the ```traffic_stop_geography()``` function to our desired input geographies. 

First, we'll create a character vector that contains the *tidycensus* codes for the geographies we'd like to use in our spatial joins; we'll assign this vector to a new object named ```desired_geography_inputs```:

```{r, message=F, results=F, warning=F}
desired_geography_inputs<-c("county", "tract", "zcta")
```

Now, we'll use *purrr's* ```map()``` function to iteratively apply ```traffic_stop_geography()``` to the inputs specified in ```desired_geography_inputs```; we'll assign the output list to a new object named ```geography_stop_list```:

```{r, message=F, results=F, warning=F}
geography_stop_list<-map(desired_geography_inputs, traffic_stop_geography)
```

Let's go ahead and print our list:

```{r}
geography_stop_list
```


Now, we can easily extract datasets for any of the specified geographies from our list, using the relevant index. For example, let's say we want to extract the county-level dataset; we can do so using index number 1 (since "county" is the first element in the ```desired_geography_inputs``` vector):

```{r, eval=F}
geography_stop_list[[1]]
```

```{r, echo=F}
geography_stop_list[[1]] %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Recall that we can also use the ```pluck()``` function to extract list elements; for example, let's say we want to extract the zip-code level dataset of police stops from ```geography_stop_list```. We can do so with the following: 

```{r, eval=F}
geography_stop_list %>% pluck(3)
```

```{r, echo=F}
zip_code_stops<-geography_stop_list %>% pluck(3)
```

```{r, echo=F}
zip_code_stops %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

It may also be convenient to assign list elements to their own objects; for instance, if we wanted to extract the zip code dataset from ```geography_stop_list```, and assign it to its own object (here, named ```police_stops_zip_code```), we could do the following:

```{r}
police_stops_zip_code<-geography_stop_list %>% pluck(3)
```

It is often convenient to explicitly name our list elements. For example, the code below uses the ```names()``` function to name the elements of ```geography_stop_list``` based on the ```desired_geography_inputs``` vector:

```{r}
names(geography_stop_list)<-desired_geography_inputs
```

Now, when we print ```geography_stop_list```, we can note that the list elements are named after the geography to which the dataset corresponds. 

```{r}
geography_stop_list
```

Now that our list is named, we can use these names to extract list elements. For example, if we wanted to extract the zip code dataset, we could use the following:

```{r, eval=F}
geography_stop_list[["zcta"]]
```

```{r, echo=F}
geography_stop_list[["zcta"]] %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

Even after naming the list, we can continue referring to the list elements by their indices as well. For example: 

```{r, eval=F}
geography_stop_list[[3]]
```

```{r}
geography_stop_list[[3]] %>% datatable(extensions=c("Scroller", "FixedColumns"), options = list(
  deferRender = TRUE,
  scrollY = 350,
  scrollX = 350,
  dom = "t",
  scroller = TRUE,
  fixedColumns = list(leftColumns = 3)
))
```

## Iteratively write out the generated CSV files to disk

```{r}
output_csv<-function(files, name){
  filename<-paste0(name, ".csv")
  write_csv(files, filename)
}
```

```{r}
# Test function
output_csv(county_subdivision_stops, "county_subdivision")
```


```{r}
walk2(geography_stop_list, desired_geography_inputs, .f=output_csv)
```

# Automating Map Creation

```{r}
country_boundaries<-ne_countries(scale="medium", returnclass="sf") %>% 
                       filter(iso_a3 !="ATA")
```

```{r}
tm_shape(country_boundaries)+
  tm_polygons()
```

```{r}
trade_gdp_2010_2018<-WDI(country="all", # specifies we want data for all countries available
                                indicator="NE.TRD.GNFS.ZS", # specifies code for desired indicator
                                start=2010, # Start year for data series
                                end=2018, # End year for data series
                                extra=T) # returns
```


```{r}
trade_gdp_2015<-
  trade_gdp_2010_2018 %>%  # Establishes object to be modified
  filter(year=="2015") %>% # Subsets observations where the "year" variable equals "2015"
  rename(trade_gdp_2015=NE.TRD.GNFS.ZS)
```


```{r}
trade_2015_spatial<-full_join(country_boundaries, trade_gdp_2015,
                                    by=c("iso_a3"="iso3c"))
```

```{r}
tm_shape(trade_2015_spatial)+
  tm_polygons(col="trade_gdp_2015",
              n=7,
              style="quantile",
              palette="YlOrBr",
              title="Trade as a % of GDP,\n2015",
              textNA="No Data")+
    tm_layout(legend.outside=T,
              legend.outside.position = "bottom",
              main.title="Crossnational Variation in Commercial Integration, 2015",
              main.title.size=1,
              main.title.position="center",
              inner.margins=c(0.06,0.10,0.10,0.08), # Sets margins to create whitespace
              frame=FALSE,
              attr.outside = TRUE)+ # Places credits section outside map
   tm_credits("Map Author: Aditya Ranganath\nData Source: World Bank\nDevelopment Indicators (WDI)", position=c(0.78,0), size=0.38) # Specifies content, position, size of credits
```


```{r}
wdi_map_maker<-function(wdi_variable_code, start_year, end_year, 
                        legend.title, main_map_title){
country_boundaries<-ne_countries(scale="medium", returnclass="sf") %>% 
                       filter(iso_a3 !="ATA")
  
wdi_extract<-WDI(country="all",
              indicator=wdi_variable_code,
              start=start_year,
              end=end_year,
              extra=T)

spatial_object_tomap<-inner_join(country_boundaries, wdi_extract,
                                    by=c("iso_a3"="iso3c"))
final_map<-tm_shape(spatial_object_tomap)+
  tm_polygons(col=wdi_variable_code,
              n=7,
              style="quantile",
              palette="YlOrBr",
              title=legend.title,
              textNA="No Data")+
    tm_layout(legend.outside=T,
              legend.outside.position = "bottom",
              main.title=main_map_title,
              main.title.size=1,
              main.title.position="center",
              inner.margins=c(0.06,0.10,0.10,0.08), # Sets margins to create whitespace
              frame=FALSE,
              attr.outside = TRUE)+ # Places credits section outside map
   tm_credits("Map Author: Aditya Ranganath\nData Source: World Bank\nDevelopment Indicators (WDI)", position=c(0.78,0), size=0.38) # Specifies content, position, size of credits
return(final_map)
}
```


```{r}
wdi_map_maker(wdi_variable_code="BG.GSR.NFSV.GD.ZS", start_year=2017, end_year=2017, 
                        legend.title="Services Trade (% of GDP)", main_map_title="Service Market Integration, 2017")
```


```{r}
wdi_map_maker(wdi_variable_code="GC.TAX.TOTL.GD.ZS", start_year=2017, end_year=2017, 
                        legend.title="Taxes (% of GDP)", main_map_title="Government Taxes as a Share of GDP, 2017")
```


```{r}
input_list<-list(wdi_variable_code=c("BG.GSR.NFSV.GD.ZS", "GC.TAX.TOTL.GD.ZS"),
                 start_year=c(2017, 2017),
                 end_year=c(2017, 2017),
                 legend.title=c("Services Trade (% of GDP)", "Taxes (%GDP)"),
                 main_map_title=c("Service Market Integration, 2017", "Government Taxes as a Share of GDP, 2017")) 
```

```{r}
map_list<-pmap(input_list, wdi_map_maker)
```

```{r}
map_list
```


```{r}
map_list[[1]]
```

```{r}
map_list[[2]]
```

```{r}
names(map_list)<-input_list$wdi_variable_code
```

```{r}
map_list
```

```{r}
map_list[["BG.GSR.NFSV.GD.ZS"]]
```

```{r}
map_list[["GC.TAX.TOTL.GD.ZS"]]
```

```{r}
map_list %>% pluck("GC.TAX.TOTL.GD.ZS")
```

## Functions and iteration with raster data

```{r, echo=-1}
setwd("/Users/adra7980/Documents/git_repositories/ARSC5040_GIS/class_notes/class5/scripting_data")

# Read in NYC 2019 Raster
nyc_pop_2019<-raster("nyc_2019_pop.tif")

# Read in NYC subway stop data
nyc_subway_stops<-st_read("stops_nyc_subway_may2019.shp")

# Read in NYC borough data
nyc_boroughs<-st_read("nyu_2451_34490.shp")

# Create 500m subway buffers
nyc_subway_500m_buffer<-st_buffer(nyc_subway_stops, 1640.42)

# Dissolve buffers
nyc_subway_500m_buffer_dissolved<-nyc_subway_500m_buffer %>% 
                                    group_by() %>% 
                                    summarise()

# Transform CRS of "nyc_subway_500m_buffer_dissolved" to match "nyc_pop_2019"
nyc_subway_500m_buffer_dissolved_4326<-nyc_subway_500m_buffer_dissolved %>% 
                                        st_transform(4326)

# Calculate population in buffer zone ("nyc_subway_500m_buffer_dissolved_4326") based on "nyc_2019_population" raster
nyc_pop_within_buffer<-exact_extract(nyc_pop_2019, nyc_subway_500m_buffer_dissolved_4326, fun="sum")

# Extract total NYC population
nyc_borough_4326<-nyc_boroughs %>% st_transform(4326)
nyc_pop<-sum(exact_extract(nyc_pop_2019, nyc_borough_4326, fun="sum" ))

# Percentage Inside Buffer
pct_inside<-(nyc_pop_within_buffer/nyc_pop)*100

# Calculate Percentage Outside Buffer
pct_outside_buffer<-100-pct_inside

# Print "pct_outside_buffer"
pct_outside_buffer
```

buffer zones function

```{r}
nyc_population_buffer<-function(buffer_distance_meters){
  buffer_distance_feet<-buffer_distance_meters*3.281
  nyc_subway_buffer<-st_buffer(nyc_subway_stops, buffer_distance_feet)
  
  nyc_subway_buffer_dissolved<-nyc_subway_buffer %>% 
                                group_by() %>% 
                                summarise()
  
  nyc_buffer_dissolved_4326<-nyc_subway_buffer_dissolved %>% 
                                st_transform(4326)
  
  
  nyc_pop_within_buffer<-exact_extract(nyc_pop_2019, nyc_buffer_dissolved_4326, fun="sum")
  
  nyc_inside_buffer_pct<-(nyc_pop_within_buffer/8309940)*100
  
  pct_outside_buffer<-100-nyc_inside_buffer_pct
  
  final_df<-as.data.frame((cbind(buffer_distance_meters, pct_outside_buffer )))
  
  return(final_df)
}
```


```{r}
nyc_population_buffer(650)
nyc_population_buffer(1000)
```


```{r}
buffer_distances<-c(250, 500, 750, 1000, 1250, 1500, 1750, 2000)
distance_table<-map_dfr(buffer_distances, nyc_population_buffer)
```

```{r}
distance_table
```



